<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>GeoAR.js demo</title>
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-look-at-component@1.0.0/dist/aframe-look-at-component.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar-nft.js"></script>
    <script>
      // A-Frame component that adds a three.js GridHelper to the entity's object3D
      AFRAME.registerComponent('ground-grid', {
        schema: {
          size: { type: 'number', default: 100 },
          divisions: { type: 'number', default: 100 },
          color1: { type: 'color', default: '#444444' },
          color2: { type: 'color', default: '#888888' },
          opacity: { type: 'number', default: 0.5 }
        },
        init: function () {
          const THREE = AFRAME.THREE;
          const data = this.data;
          this.grid = new THREE.GridHelper(data.size, data.divisions, new THREE.Color(data.color1), new THREE.Color(data.color2));
          // Ensure material supports transparency
          if (this.grid.material) {
            this.grid.material.opacity = data.opacity;
            this.grid.material.transparent = data.opacity < 1;
          } else if (this.grid.children && this.grid.children.length) {
            this.grid.children.forEach((c) => {
              if (c.material) {
                c.material.opacity = data.opacity;
                c.material.transparent = data.opacity < 1;
              }
            });
          }
          // Place on ground (y = 0) relative to this entity
          this.grid.position.y = 0;
          // Add to this element's object3D so it moves with gps-entity-place
          this.el.object3D.add(this.grid);
        },
        remove: function () {
          if (this.grid && this.el && this.el.object3D) {
            this.el.object3D.remove(this.grid);
            this.grid = null;
          }
        }
      });

      // Component that updates its host element's gps-entity-place using device geolocation
      AFRAME.registerComponent('gps-grid', {
        schema: {
          watchOptions: { type: 'string', default: '' }
        },
        init: function () {
          this.watchId = null;
          this._onPosition = this._onPosition.bind(this);
          this._onError = this._onError.bind(this);
          if ('geolocation' in navigator) {
            try {
              this.watchId = navigator.geolocation.watchPosition(this._onPosition, this._onError, { enableHighAccuracy: true, maximumAge: 1000, timeout: 27000 });
            } catch (e) {
              console.warn('gps-grid: geolocation watch failed', e);
            }
          } else {
            console.warn('gps-grid: Geolocation not available on this device');
          }
        },
        _onPosition: function (pos) {
          const lat = pos.coords.latitude;
          const lon = pos.coords.longitude;
          // Update gps-entity-place attribute so AR.js places this entity at device location
          this.el.setAttribute('gps-entity-place', `latitude: ${lat.toFixed(5)}; longitude: ${lon.toFixed(5)};`);
          // update overlay
          try {
            const coords = document.getElementById('coords');
            if (coords) coords.textContent = `Lat: ${lat.toFixed(5)}, Lon: ${lon.toFixed(5)}, Acc: ${pos.coords.accuracy}m`;
          } catch (e) { /* ignore */ }
          console.log(`gps-grid._onPosition: ${lat.toFixed(5)}, ${lon.toFixed(5)}, acc=${pos.coords.accuracy}`);
        },
        _onError: function (err) {
          console.warn('gps-grid geolocation error', err);
        },
        remove: function () {
          if (this.watchId !== null && 'geolocation' in navigator) {
            navigator.geolocation.clearWatch(this.watchId);
            this.watchId = null;
          }
        }
      });
      
      // A-Frame component that adds a small box at the entity's origin (user's feet)
      AFRAME.registerComponent('foot-box', {
        schema: {
          width: { type: 'number', default: 0.3 },
          height: { type: 'number', default: 0.1 },
          depth: { type: 'number', default: 0.3 },
          color: { type: 'color', default: '#00FFCC' },
          opacity: { type: 'number', default: 0.9 }
        },
        init: function () {
          const THREE = AFRAME.THREE;
          const d = this.data;
          const geo = new THREE.BoxGeometry(d.width, d.height, d.depth);
          const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color(d.color), transparent: d.opacity < 1, opacity: d.opacity });
          this.box = new THREE.Mesh(geo, mat);
          // Place box so its top sits at y = 0 (so it appears on the ground)
          this.box.position.y = d.height / 2 * -1 + (d.height / 2);
          // More straightforward: set top at y=0 => center at y = height/2
          this.box.position.y = d.height / 2;
          this.el.object3D.add(this.box);
        },
        remove: function () {
          if (this.box && this.el && this.el.object3D) {
            this.el.object3D.remove(this.box);
            this.box.geometry.dispose();
            if (this.box.material && this.box.material.dispose) this.box.material.dispose();
            this.box = null;
          }
        }
      });

      // Component that generates a grid of tiles (each with a foot-box) at fixed lat/lon intervals
      AFRAME.registerComponent('gps-tiles', {
        schema: {
          centerLatitude: { type: 'number', default: NaN },
          centerLongitude: { type: 'number', default: NaN },
          follow: { type: 'boolean', default: false },
          tileSizeMeters: { type: 'number', default: 2 },
          radiusMeters: { type: 'number', default: 20 },
          spacingMeters: { type: 'number', default: 2 }
        },
        init: function () {
            this.tiles = [];
            this._generateTiles = this._generateTiles.bind(this);
            this.lastCenter = null;
            this.watchId = null; // used for regen when follow=true
            this.offsetWatchId = null; // used to update container offset for game-like movement
            this.container = null; // container entity that is gps-anchored
          // If center lat/lon is provided, generate immediately
          if (!isNaN(this.data.centerLatitude) && !isNaN(this.data.centerLongitude)) {
            this._generateTiles();
            return;
          }
          // Otherwise use device location once by default; if follow:true, use watchPosition
          if (!('geolocation' in navigator)) {
            console.warn('gps-tiles: geolocation not available');
            return;
          }
          if (this.data.follow) {
            // continuous watch and regenerate when moved enough (keeps original behavior)
            this.watchId = navigator.geolocation.watchPosition((pos) => {
              const lat = pos.coords.latitude;
              const lon = pos.coords.longitude;
              try { const coords = document.getElementById('coords'); if (coords) coords.textContent = `Lat: ${lat.toFixed(5)}, Lon: ${lon.toFixed(5)}, Acc: ${pos.coords.accuracy}m`; } catch (e) {}
              const moved = !this.lastCenter || this._distanceMeters(this.lastCenter.lat, this.lastCenter.lon, lat, lon) > (this.data.spacingMeters / 2);
              if (!this.lastCenter || moved) {
                this.data.centerLatitude = lat;
                this.data.centerLongitude = lon;
                this.lastCenter = { lat, lon };
                this._generateTiles();
              }
              // Always update container offset if present so visual offset stays in sync
              if (this.container) this._updateContainerOffset(lat, lon);
            }, (err) => { console.warn('gps-tiles watch error', err); }, { enableHighAccuracy: true, maximumAge: 1000 });
          } else {
            // single sample as fixed center: generate world-anchored tiles once,
            // then start a separate watcher that only updates the container local offset
            navigator.geolocation.getCurrentPosition((pos) => {
              const lat = pos.coords.latitude;
              const lon = pos.coords.longitude;
              try { const coords = document.getElementById('coords'); if (coords) coords.textContent = `Lat: ${lat.toFixed(5)}, Lon: ${lon.toFixed(5)}, Acc: ${pos.coords.accuracy}m`; } catch (e) {}
              this.data.centerLatitude = lat;
              this.data.centerLongitude = lon;
              this._generateTiles();
              // start offset watcher to simulate camera-relative movement without regenerating
              this._startOffsetWatcher();
            }, (err) => { console.warn('gps-tiles: cannot get device location', err); }, { enableHighAccuracy: true });
          }
        },
        _generateTiles: function () {
          const centerLat = this.data.centerLatitude;
          const centerLon = this.data.centerLongitude;
          const tileSize = this.data.tileSizeMeters;
          const radius = this.data.radiusMeters;
          const spacing = this.data.spacingMeters;
          if (isNaN(centerLat) || isNaN(centerLon)) return;

          // Approx meters per degree
          const metersPerDegLat = 111320;
          const metersPerDegLon = 111320 * Math.cos(centerLat * Math.PI / 180);

          const half = Math.ceil(radius / spacing);

          // remove existing
          if (this.container && this.container.parentNode) {
            this.container.parentNode.removeChild(this.container);
          }
          this.tiles = [];
          this.container = document.createElement('a-entity');
          // Anchor the container in world space using a single gps-entity-place
          this.container.setAttribute('gps-entity-place', `latitude: ${centerLat}; longitude: ${centerLon};`);
          // ensure the container has no visual representation itself
          this.container.setAttribute('id', 'gps-tiles-container');
          this.el.sceneEl.appendChild(this.container);

          for (let dx = -half; dx <= half; dx++) {
            for (let dy = -half; dy <= half; dy++) {
              const east = dx * spacing;
              const north = dy * spacing;
              // local child position in meters: x = east, z = -north (Three.js forward = -Z)
              const px = east;
              const pz = -north;
              const el = document.createElement('a-entity');
              el.setAttribute('position', `${px} 0 ${pz}`);
              el.setAttribute('foot-box', `width: ${tileSize}; height: 0.12; depth: ${tileSize}; color: #ff3333; opacity: 0.95`);
              this.container.appendChild(el);
              this.tiles.push(el);
            }
          }
          console.log(`gps-tiles: generated ${this.tiles.length} tiles around ${centerLat.toFixed(5)}, ${centerLon.toFixed(5)}`);
          // if not following/regenerating, start a watcher to update container offset
          if (!this.data.follow) {
            // offset watcher started in init after generation for single-shot case
          }
        },

        _startOffsetWatcher: function () {
          if (!('geolocation' in navigator)) return;
          if (this.offsetWatchId !== null) return;
          // Watch position to update container local position (simulate camera movement)
          this.offsetWatchId = navigator.geolocation.watchPosition((pos) => {
            const lat = pos.coords.latitude;
            const lon = pos.coords.longitude;
            this._updateContainerOffset(lat, lon);
          }, (err) => { console.warn('gps-tiles offset watch error', err); }, { enableHighAccuracy: true, maximumAge: 1000 });
        },

        _updateContainerOffset: function (lat, lon) {
          if (!this.container) return;
          const centerLat = this.data.centerLatitude;
          const centerLon = this.data.centerLongitude;
          if (isNaN(centerLat) || isNaN(centerLon)) return;
          const metersPerDegLat = 111320;
          const metersPerDegLon = 111320 * Math.cos(centerLat * Math.PI / 180);
          const north = (lat - centerLat) * metersPerDegLat;
          const east = (lon - centerLon) * metersPerDegLon;
          // Set container local position so that when user moves north, container.z increases
          // child world z = childLocalZ + container.z; childLocalZ = -northTile
          this.container.object3D.position.x = -east;
          this.container.object3D.position.z = north;
        },

        _distanceMeters: function (lat1, lon1, lat2, lon2) {
          // approximate haversine
          const R = 6371000;
          const toRad = Math.PI / 180;
          const dLat = (lat2 - lat1) * toRad;
          const dLon = (lon2 - lon1) * toRad;
          const a = Math.sin(dLat/2)*Math.sin(dLat/2) + Math.cos(lat1*toRad)*Math.cos(lat2*toRad)*Math.sin(dLon/2)*Math.sin(dLon/2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
          return R * c;
        },
        remove: function () {
          if (this.watchId !== null && 'geolocation' in navigator) {
            navigator.geolocation.clearWatch(this.watchId);
            this.watchId = null;
          }
          this.tiles.forEach((el) => el.parentNode && el.parentNode.removeChild(el));
          this.tiles = [];
        },
      });

      // Lightweight debug component: watch device geolocation and update the DOM overlay
      // This does NOT modify any scene entities or gps-entity-place attributes.
      AFRAME.registerComponent('pos-debug', {
        init: function () {
          this.watchId = null;
          if (!('geolocation' in navigator)) {
            console.warn('pos-debug: geolocation not available');
            return;
          }
          this.watchId = navigator.geolocation.watchPosition((pos) => {
            const lat = pos.coords.latitude;
            const lon = pos.coords.longitude;
            const acc = pos.coords.accuracy;
            try {
              const coords = document.getElementById('coords');
              if (coords) coords.textContent = `Lat: ${lat.toFixed(5)}, Lon: ${lon.toFixed(5)}, Acc: ${acc}m`;
            } catch (e) {}
            console.log('pos-debug._onPosition', lat.toFixed(5), lon.toFixed(5), 'acc=' + acc);
          }, (err) => {
            console.warn('pos-debug error', err);
          }, { enableHighAccuracy: true, maximumAge: 1000 });
        },
        remove: function () {
          if (this.watchId !== null && 'geolocation' in navigator) {
            navigator.geolocation.clearWatch(this.watchId);
            this.watchId = null;
          }
        }
      });
    </script>
  </head>

  <body>
    <style>
      #coords {
        position: fixed;
        left: 8px;
        top: 8px;
        background: rgba(0,0,0,0.6);
        color: #fff;
        padding: 8px 10px;
        font-family: monospace;
        font-size: 13px;
        border-radius: 6px;
        z-index: 9999;
      }
    </style>
    <div id="coords">Lat: --, Lon: --, Acc: --</div>
    <a-scene
      vr-mode-ui="enabled: false"
      arjs="sourceType: webcam; videoTexture: true; debugUIEnabled: false;"
    >
  <!-- Generate a grid of tiles (each a small box) around the device location -->
  <!-- Use a single-shot (follow: false) generation so tiles are fixed in world coordinates
    and will visually approach as you walk. spacingMeters reduced for testing. -->
  <!-- Place tiles at a specific latitude/longitude (example: Taipei Main Station) -->
  <a-entity gps-tiles="centerLatitude: 25.03217; centerLongitude: 121.54740; follow: false; tileSizeMeters:1; radiusMeters:10; spacingMeters:3"></a-entity>
  <!-- Note: removed the continuous gps-grid watcher which repeatedly updates an element's
    gps-entity-place. In some AR.js setups that can cause the origin to be re-centered
    and make world-fixed objects appear to stay at a constant distance. If you still
    want a continuous overlay of current coords, we can add a watcher that does NOT
    modify scene origin (or update an on-screen DOM element directly). -->
  <!-- Invisible debug entity: starts pos-debug (doesn't change scene origin) -->
  <a-entity pos-debug style="display:none"></a-entity>
  <a-camera id="camera" gps-camera rotation-reader> </a-camera>
    </a-scene>
  </body>
</html>
